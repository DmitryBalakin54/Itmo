## ITERATE ME

`control flow` `list` `range` `enumerate` `reversed` `int` `sum`

### Условие

Реализуйте функции:

* `get_squares` - возвращает квадрат значений. Используйте `**` для возведения в степень
* `get_indices_from_one` - возвращает список индексов элементов, начиная с 1
* `get_max_element_index` - возвращает индекс максимального элемента
* `get_every_second_element` - возвращает список вторых элементов
* `get_first_three_index` - возвращает индекс первой встречаемой в списке тройки
* `get_last_three_index` - возвращает индекс последней встречаемой в списке тройки
* `get_sum` - возвращает сумму элементов. Используйте `sum()`
* `get_min_max` - возвращает `tuple` с минимумом и максимум, если список не пустой, иначе дефолтное значение для минимума и максимума. Используйте `min` и `max`
* `get_by_index` - возвращает элемент по переданному индексу, если он больше границы. Иначе возвращает None. 
Предполагаем, что индекс всегда существует. 
Используйте оператор `:=` и попробуйте написать в одну строчку с помощью тернарного оператора. См. мотивацию ниже.

Обратите внимание на краевые случаи. 

### Про задачу

Здесь мы отрабатываем выбор правильной итерации. Мы можем итерироваться:
* по индексам
* по значениям
* и по индексам и по значениям
* с помощью for
* с помощью while

Также использование стандартные конструкций, когда можно написать без итерации.

Выберете самый подходящий способ под каждую микрозадачку.

### Про `get_by_index`

Это маленькая модельная задачка. Представьте, что обращение по индексу работает достаточно долго (внутри какая-нибудь функция вычисляется). Обычный код вида
`return a[i] if a[i] > 0 else 0` берет по индексу дважды. Используя "моржовый" оператор получится обратиться по индексу один раз и сохранить при этом компактность записи.
