## BIN TRICKY

`control flow` `binary search` `list` `len` `//` `%` `job interview medium`

### Условие

Найти [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)) двух отсортированных списков. В списках могут быть дубликаты.
Если количество элементов четное, то нужно взять среднее арифметическое двух серединных значений.
Гарантируется, что хоты бы один список не пустой.

* Постарайтесь сразу до написания ответить на вопрос, что лучше в данном контексте for или while
* Постарайтесь написать самым читабельным способом
* Оцените сложность по времени и памяти - у вас должно получиться О(log (m + n)) и O(1)
* Не модифицируйте входы, это плохая практика, если это не нужно
* Может быть несколько `return` в цикле
* Обратите внимание, что медиана есть всегда, поэтому `return` в цикле достаточно, и его не нужно ставить в конце функции.
* Для того, чтоб mypy справлялся с распознаванием типа в конце функции, рекомендуем ставить конструкцию вида `assert False, "Not reachable"`. Рассуждение на эту тему читайте ниже.
* Вам нужно возвращать значения всегда одного и того же типа


### Пример

```python
>>> find_median([1, 2], [3])
2.0
>>> find_median([1, 2], [3, 4])
2.5
```

### Про задачу

Это достаточно сложная модификация бинпоиска. В голове нужно держать сразу два индекса и жонглировать двумя массивами.

Эта задача некогда была популярной на собеседованиях в компанию-которую-нельзя-называть.

Тут, как и в прошлой задаче, тесты сделаны через примитивную реализацию функции нахождения медианы. 
Это гораздо проще, чем высчитывать для теста каждый раз медиану вручную.

Обратите внимание на условие про возвращение одного типа. 
Казалось бы, это не важно, какой именно numeric тип на выходе.
Но ограничивая выходы - вы ограничиваете неопределенность. Человек, который после вас будет читать эту функцию 
будет уверен, что всегда работает с `float`, и с меньшей вероятностью ошибется.

### Подсказка

Подумайте, как соотносятся между собой индексы средних значений в двух массивах? Можно ли выразить один через другой?
Если есть два индекса `i` и `j` в массивах `nums1` и `nums2`, 
то как должны соотносится между собой `nums1[i]`, `nums1[i+1]`, `nums2[j]`, `nums2[j+1]`?

### Рассуждение на тему `assert False, "Not reachable"`

У нас есть задача:
* не путать читателя, что из функции можно выйти мимо `while` (не пишем `return`)
* чтоб mypy замолчал в этом случае (надо что-то написать)
* не путать читателя, что может вылететь исключение (не пишем `Exception`)

Читабельный вариант - писать `assert not "Reachable”`.
В задачке `make_assert` разбирается, что пишем assert при проверке того, чего не может случиться в принципе. 
Это как раз тот случай.
