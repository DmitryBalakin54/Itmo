## COMPREHENSIONS

`comprehensions` `dict` `list` `set`

### Условие

Нужно реализовать функции по процессингу записей.
Что должна делать функция, какие типы возвращать - ищите в коде и тестах :)

* нужно использовать именно `comprehensions`, а не `map` и `filter`
* реализация каждой функции должна занимать одну строчку. Итого - 10 строк кода и задачка сдана :)

### Пример

```python
>>> record = {"EventID": 1, "EventTime": None, "UserID": None, "PageID": None, "RegionID": None, "DeviceType": None}
>>> get_keys_where_value_is_not_none(record)
>>> ["EventID"]
```

### Про предметную область

Строчки, которые заданы в `TEST_RECORDS` - это такой себе кусочек Hit-лога.
Каждая строчка в нем (hit) - это событие запроса рекламы при загрузке web-страницы.
* EventID -  идентификатор события
* EventTime - [таймстемп](https://ru.wikipedia.org/wiki/Unix-время) события. Время очень удобно хранить в unix-таймстемпах, потому что не надо возиться с временными зонами.
* UserID - идентификатор пользователя
* PageID - идентификатор web-страницы
* RegionID - регион пользователя
* DeviceType - устройство, с которого зашел пользователь

Обратите внимание, что мы именуем все строки `records`, а одну строку `r`.
Здесь однобуквенная переменная возможна, так как это common knowledge в коде,
все знают что это и используют для обозначений строчек лога.


### Про задачу

Функций аж 10 для того, чтоб вы попробовали все виды компрехеншенов и набили руку на задании условий в них.

Для многих эта конструкция крайне непривычна. Но когда вы научитесь выстраивать
вербально предложения для условий, то эта конструкция станет для вас невероятно выразительной :)

Многие почему-то любят писать `map` и `filter`, хотя это менее читабельно.

В этих задачках нет сложных условий, каждая строчка выходит адекватной длины.
Если бы условий было больше, то компрехеншн бы тяжело читался. В этом случае лучше вернуться к привычному циклу.

Обратите внимание, что итерирование по ключам словаря - не требует явного извлечения ключей через `.keys()`.

> Сейчас каждый запрос вынесен в отдельную функцию. Для однострочников это очень часто не оправдано.
И часто лучше писать такой однострочник прямо в коде, чем именовать и выделять отдельную функцию
