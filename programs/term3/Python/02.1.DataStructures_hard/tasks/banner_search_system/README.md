## BANNER SEARCH SYSTEM

Proposed by @firefish

`control flow` `heapq` `list` `dict` `defaultdict` `enumerate` `string`

### Условие

Вам нужно написать набор функций, которые помогут определять с какими баннерами матчатся запросы.
Слова в запросах и баннерах для упрощения уже без склонений.

* `normalize` - воспользуйтесь методами строки для удаления пунктуации и цифр, а также приведите к нижнему регистру 
* `get_words` - воспользуйтесь методом строки для разбиения ее на куски. И тут ваш любимый `comprehension`)
* `build_index` - постройте индекс встречаемости слов по баннерам. `defaultdict` может помочь
* `get_banner_indices_by_query` - а тут вам надо найти те баннера, где есть все слова из запроса. 
Не забудьте обработать запрос по тем же правилам, что баннера в индексе. Здесь вам нужно прикрутить мердж с использованием `heapq`, как в задачке `merge_lists_2`. Почему - читай ниже

### Пример

```python
>>> normalize("Джинсы со скидка 600р")
"джинсы со скидка р"
>>> get_words("джинсы со скидка р")
["джинсы", "скидка"]
>>> build_index(["Джинсы со скидка 600р"])
{"джинсы": [0], "скидка": [0]}
>> get_banner_indices_by_query("Джинсы 300р", {"джинсы": [0], "скидка": [0]})
[0]
```

### Про задачу

В этой задаче вы
* примените мердж n списков с небольшим наворотиком
* чуток копнете в методы стринга
* потренируетесь жонглировать списками и диктами - самый важный навык =)

Эту задачу предложил Юра @firefish. 

В рекламе есть такое понятие как "таргетинг". Таргетинг - способ отбора баннеров для показа.
Когда вы ищете что-то в поиске, то на каждый ваш запрос срабатывает куча таргетингов, которые отбирают баннера.

Мы можем сделать такой таргетинг: берем поисковый запрос, нормализуем. Дальше среди заголовков миллионов баннеров в базе находим те, которые совпадают с текстом запроса. Дальше отправляем их на ранжирование. 

Эта задача - упрощенный вариант пайплайна этого таргетинга

### Почему мердж списков

При построении индекса у тебя получается на каждое слово - список индексов баннеров, где оно встречается. 
Сравните имплементации:

```python
from itertools import chain
from collections import Counter

INDEX = {
   "купить": [0, 1, 2, 3, 4, 5, 6],
   "джинсы": [2, 3, 4],
   "скидка": [0, 3, 4, 5]
}

QUERY = ["купить", "джинсы", "скидка"]


# k - число слов в запросе
# ni - число баннеров у слова i в запросе
# n - max(n1,..., nk) максимальное число баннеров среди слов запроса


# Counter implementation
# Используем счетчик и берем те, у которых значение счетчика равно длине запроса
# В худшем случае:
#    память: О(nk),     если у всех слов разные баннера
#    скорость: О(nk)
def get_banner_indices_by_query_counter(query, index):
    lists = [index[word] for word in query]
    return [key for key, value in Counter(chain(*lists)).items() if value == len(query)]


# Set implementation
# Выражаем списки баннеров как сеты и пересекаем
# В худшем случае:
#    память: О(nk),     все в сеты кладем. Если б передавали сеты, было б О(n). Также можно пересекать по очереди за O(n)
#    скорость: О(nk),  если у всех слов одинаковые баннера (не учитывая возможные коллизии). Теряем порядок. С учетом порядка - O(nk + nlogn)
def get_banner_indices_by_query_set(query, index):
    sets = [set(index[word]) for word in query]
    return list(set.intersection(*sets))


# Merge implementation
# Слияние - как merge_lists. Но с правилом отбора - возьми, если есть k одинаковых баннера подряд
# Не теряем порядок
# В худшем случае:
#    память: О(n),      если у всех слов одинаковые баннера
#    скорость: О(nklogk)
def get_banner_indices_by_query_merge(query, index):
    pass

print(get_banner_indices_by_query_counter(QUERY, INDEX))
print(get_banner_indices_by_query_set(QUERY, INDEX))
```

Давайте еще мысленно продолжим задачу:

* Мы можем хотеть обрабатывать потоки и складывать в потоки. С мерджем это можно за О(k) памяти сделать
* Мы можем хотеть это сделать не про все баннера, а вернуть некоторый топ. Это сильно уменьшает константу по времени
