## NORMALIZE PATH

`unix path` `stack` `split` `join` `interview`

### Условие

Написать функцию `normalize_path`, которая принимает на вход
[unix-путь](http://teaching.idallen.com/cst8207/12w/notes/150_pathnames.txt)
и выдает его нормализованный вариант (т.е. схлопываются слеши, обрабатываются все возможные точки).

Каталоги разделяются слэшами (`/`). Подряд может идти несколько слэшей (`///`). Если указан символ точка `.` - это
означает текущую папку. Если указано два символа точки подряд `..` - это означает ссылку на родительскую папку.
Требуется получить нормализованное представление.

Более строго:

Два `/` идущих подряд всегда можно заменить на один:
- `/foo//bar` -> `/foo/bar`

Точку `.` можно удалить, если в итоговом пути останется хотя бы 1 символ:
- `foo/./bar` -> `foo/bar`
- `./foo` -> `foo`
- `.` -> `.`

Две точки `..` можно сократить со стоящим впереди именем.
- `foo/../bar` -> `bar` - простой случай
- `/../../../zog` -> `/zog` - случай корня
- `zog/..` -> `.` - упрощение до текущей директории
- `./../../../zog` -> `../../../zog` - случай точки в начале

Существует стандартная функция `os.path.normpath` для решения такой задачи, но она довольно не оптимальная. Вам нужно написать функцию, которая, как минимум, не хуже.   
(Пользоваться функцией `os.path.normpath` запрещается). 


### Примеры
```python
>>> normalize_path('/foo/bar//baz/asdf/quux/..')
'/foo/bar/baz/asdf'

>>> normalize_path('./config/../etc')
'etc'

>>> normalize_path('/////documents/root/.././../etc')
'/etc'

>>> normalize_path('a/../../b')
'../b'
```


### Про задачу

Это одна из задач, которая является простой для понимания, однако дьявол кроется в деталях :)
Её могут дать на интервью, так как она не требует много времени на написание, но в то же время проверяет
внимательность кандидата к граничным условиям.
