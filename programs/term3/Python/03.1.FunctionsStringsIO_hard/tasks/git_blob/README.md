## GIT BLOB

`git` `blob` `zlib` `byte strings` `pathlib` `file system traversing` `hex encoding`

### Условие

Легенда: жесткий диск, где лежала копия репозитория c неким чат-ботом, вышел из строя,
удалось восстановать только часть файлов.
Вам дан битый git-репозиторий, в котором уцелели только некоторые объекты и история коммитов.
Нужно выяснить, какой библиотекой для работы с API телеграма пользовался автор, для этого вам нужно
найти первый коммит и вытащить из него содержимое файлика `requirements.txt`
(проверяется в последнем тесте, но можете вытащить весь файл и посмотреть глазами ради интереса).

### Устройство гита

Для начала рекомендуется почитать, [как устроен гит внутри](https://git-scm.com/book/ru/v2/Git-изнутри-Объекты-Git),
все, что будет дальше написано так или иначе подчерпнуто оттуда.

#### Blob
Гит хранит все объекты в директории `.git/objects` (на самом деле не всегда, но в рамках данной задачи это не важно),
структура такова:
```bash
$ tree objects
objects
├── 13
│   ├── 7eb3a044c05f7333c00b3cba8be3f40fb68bf4
│   └── e993c9d3fe094a9a66dc03e0180c8fd8e5e4bd
├── 1b
│   └── d9ee3785043bb23af69523af7a59b43d1fe533
├── 23
│   └── 4596c32559c78f3b65568bc864f37bd9abf10f
├── 3f
│   └── d51de4c32e61a527c05848230262aa2cb1aca9
...
```
Каждый объект имеет имя в виде хэша (если точнее, то SHA-1 от содержимого),
причем полный хэш объекта складывается из имени директории,
где он лежит (первые 2 символа) и самого имени файла, итого 40 символов.

Некоторые из этих хэшей являются хэшами коммитов
(которые можно обычно видеть при работе с гитом, например, в `git log`).

Для хождения по файловой системе вам пригодится модуль `pathlib`, он гораздо удобнее и современнее `os.path`.

Итак, все хранилище гита представляет собой объекты трех типов: `tree` / `commit` / `blob`, причем термин `blob`
(Binary Large Object) можно отнести ко всем трем, поэтому последний следует понимать, как
просто файл в бинарном формате, не имеющий внутри никакой четкой структуры.

Для того, чтобы работать с содержимым блоба, его достаточно разархивировать. Для сжатия используется `zlib`,
[доступная в питоне](https://docs.python.org/3/library/zlib.html#zlib.decompress) из коробки.

Если распаковать произвольный блок, то можно увидеть, что его содержимое человекочитаемое:
```bash
$ zlib-flate -uncompress < objects/13/7eb3a044c05f7333c00b3cba8be3f40fb68bf4
blob 63.ipynb_checkpoints
.idea
*.py[cod]
venv
__pycache__
.env
*.crt
```

Каждый блоб гита имеет следующий формат: `<type>\s<content length>\0<content>`, то есть сначала идет заголовок, где
первым указывается тип, потом 1 пробельный символ и длина содержимого блоба (без заголовка). Заголовок завершается
нулевым символом (символ с кодом 0, он же `\0` из C, в питоне его можно задать так: `b'\x00'`), далее идут данные
блоба, в зависимости от типа они могут как иметь какой-либо формат, так и нет (произвольные данные пользователя).

#### Commit
Рассмотрим устройство коммита:
```bash
$ zlib-flate -uncompress < objects/1b/d9ee3785043bb23af69523af7a59b43d1fe533
commit 247tree 32815d364b4db13cc6758fa34f3ece2b50f7059b
parent a9eb7354ef5252a77157bd34ba01150065eb8e98
author Vadim Mazaev <vadim-mazaev@mail.ru> 1521759415 +0300
committer Vadim Mazaev <vadim-mazaev@mail.ru> 1521759415 +0300

Minor fixies for stabilizing
```
Видно, что сначала идет заголовок, затем длина тела в символах (потом не отображаемый `\0`) и дальше тело
коммита.

Тело делится на заголовок и сообщение коммита, между ними 1 пустая строка (точно такой же принцип импользуется в HTTP).
Заголовок состоит из n строк в формате `<key>\s<value>\n`, т.е. ключ, пробел и значение до конца строки.
При этом поле `parent`, насколько мне известно, единственное может повторяться несколько раз
(например, у merge-коммитов 2 родителя, и тут будут указаны их хэши), или вовсе отсутствовать (первый коммит).

#### Tree
Каждый коммит содержит хэш дерева. Дерево - это специальный блоб, являющийся аналогом директории (папки, если угодно).
Дерево содержит список из имен и хэшей файлов в директории (а так же прав доступа, но они нам не понадобятся).
Если же в директории есть вложенная поддиректория, то она включается в список наравне с файлами, т.к. тоже имеет имя
и хэш, но этот хэш будет ссылаться на блоб-дерево. Таким образом блоб-дерево не является деревом сам по себе, но
содержит ссылки (в виде хэшей) на другие блобы - файлы (листья) и директории (узлы), отсюда и название.

Формат дерева более сложный для восприятия человеком (и не описан по ссылке выше).
Если попытаться вывести его в консоль, то получим практически нечитаемую кашу (остается в виде упражнения читателю).
Причина в том, что для оптимизации хэши-ссылки внутри дерева хранятся в бинарном формате.

В итоге тело блоба-дерева выглядит так: `<mode>\s<name>\0<20 x bytes>...`, т.е. без проблов и переносов строк подряд
указаны данные. Для каждого объекта сначала идет заголовок произвольной длины, завершающийся `\0` (в нем указаны
права на файл и его имя через пробел), а потом 20 байт хэша.

Почему же 20 байт, если выше я писал, что хэш состоит из 40 символов. Дело в следующем: 1 беззнаковый байт может
принимать одно из 256 значений, что в шестнадцатеричной системе представляется в виде 2-х символов - от 00 до ff.
Т.е. 2 символа хэша в текстовом формате занимают 1 байт в бинарном. Текстовое представление 16-ричных данных носит
название HEX (hexadecimal).

В питоне получить текстовое представление из байт можно с помощью одноименного метода
байтовой строки: `b'\x00\xfa\xbe\x0'.hex() -> '00fabede0a'`. При этом иногда байты сами по себе могут
соответствовать печатному символу, поэтому если напечатать байтовую строку, то можно получить кашу из печатных
и непечатных символов:
```python
>>> b'\x68\x65\x6c\x6c\x6f\x00\x77\x6f\x72\x6c\x64'
b'hello\x00world'
```

В рамках задачи вам предлагается рекурсивно обойти дерево из первого коммита и найти хэш файла с определенным именем,
чтобы потом получить его содержимое.

#### Data
Кроме двух выше перечисленных типов блобов остаются только 1 тип для пользовательских данных. Эти данные будут
иметь обычный для всех блобов заголовок (с типом `blob` некоторая тавтология и длиной остального содержимого) и
пользовательские данные в том формате, в котором они были сохранены в гите.

Пример:
```bash
$ zlib-flate -uncompress < objects/4f/bd193c2c900a91969c8f37a74767504fb9bac3
blob 169CONTAINER_PORT=8000
BOT_TOKEN=YOUR_BOT_TOKEN
API_ENDPOINT=https://example.com/search/
WEBHOOK_HOST=https://example.com
CERTIFICATE_PATH=/path/to/self/signed/certificate
```

### Рекомендации по решению
В задаче вам уже будет дан набор типов для работы с основными объектами, которые вам придется обрабатывать:
`Blob` / `Commit` / `Tree`, а также вспомогательный тип `BlobType`, который поможет избежать сравнения типов в виде строк
(ниже риск ошибиться). Воспользуйтесь, пожалуйста, данными типами.
```python
>>> blob = Blob(type_=BlobType.from_bytes(b'commit'), content=b'...')
>>> blob
Blob(type_=<BlobType.COMMIT: b'commit'>, content=b'...')
>>> blob.type_ is BlobType.COMMIT
True
```

Также, как обычно, задача представляет из себя набор функций, которые вам необходимо реализовать.
Основные сценарии проверяются в тестах, но, например, в тестах не проверяется поведение, если в функцию передать
заведомо некорректные данные (например, в функцию парсинга коммита передать блоб-дерево). Проверять поведение
вашего кода в таких случаях мы не планируем, но было бы неплохо, если бы вы пользовались `assert`'ами для себя.

Набор функций для реализации:
* `read_blob` - читает блоб из файла, парсит заголовок и возвращает тип `Blob`;
* `traverse_objects` - обходит файловое дерево объектов (лежат рядом с задачей в директории `objects`), парсит их
с помощью `read_blob` и собирает в маппинг, вида хэш -> блоб;
* `parse_commit` - принимает на вход `Blob` с типом `BlobType.COMMIT`, парсит его содержимое и возвращет тип `Commit`
* `parse_tree` - аналогично принимает блоб с типом `BlobType.TREE` и парсит его содержимое. Рекурсивный обход не делает!
Работает только с 1 уровнем вложенности, всех потомков возвращает в виде маппинга имя -> блоб,
никак не обрабатывая их тип. Для работы требует список всех доступных блобов в виде маппинга по хэшу (из
`traverse_objects`).
* `find_initial_commit` - проходит все блобы-коммиты и находит самый первый коммит в репозиторий.
* `search_file` - рекурсивно обходит переданное в качестве корня дерево, ищет файл с заданным именем и возвращет его.

### Про задачу

Эта задача призвана показать, что сложные на первый взгляд системы внутри могут быть устроены
довольно просто. Также научит вас работать с байтовыми строками, парсингом структурированных данных, ходить по
файловой системе и разжимать сжатые данные.
