## TIME TO RANGE

`datetime` `timedelta` `Enum` `Callable` 

### Условие

Нужно написать:

* Класс `GranularityEnum` наследник `Enum` с аттрибутами `DAY`, `TWELVE_HOURS`, `HOUR`, `THIRTY_MIN`, `FIVE_MIN`, значениями которых
являются timedelta соответствующие названию.

* Функцию `truncate_to_granularity`, которая умеет обрезать переданный в нее `datetime` до заданной гранулярности.

* Класс-callable `DtRange`, который при вызове умеет вернуть список дат заданной гранулярности относительно некоторого `datetime`. 
Параметры конструктора:
  * `before` - сколько взять `datetime`-ов **до** переданного
  * `after` - сколько взять `datetime`-ов **после** переданного
  * `shift` - насколько сместить переданный `datetime`
  * `gtd` - гранулярность

В публичный интерфейс класса должен входить только его метод ```__call__```

* Функцию `get_interval`, которая умеет найти все `datetime` заданной гранулярности в некотором интервале. 

См. примеры ниже и в тестах.

### Про задачу

Это функции, взятые из наших продакшен утилит. 

В хранилище хранятся таблицы (некие именованные файлы с данными). 
Таблицы складываются с некоторой гранулярностью: каждый день, каждый час, каждые пять минут и тд. 

Эта гранулярность отражена в имени таблицы в виде даты. Например,
* имена таблиц с гранулярностью 5 минут - `visit_log/5min/2020-09-30T10:00:00`, `visit_log/5min/2020-09-30T10:05:00` ...
* имена таблиц с гранулярностью 30 минут - `visit_log/30min/2020-09-30T10:00:00`, `visit_log/30min/2020-09-30T10:30:00` ...

Чтоб сформировать пути к таблицам, нам нужно получить правильный набор дат. 

Возьмем для примера **гранулярность в 1 час**.

**Запрос: "для текущего момента времени дай предваряющую его дату"**

Предположим, что сейчас на часах `2020-09-30T23:18:24`. 
Находим ближайшую валидную дату для нашей гранулярности `2020-09-30T23:00:00`. 

```python
# Обрезаем до гранулярности
> dt = truncate_to_granularity(datetime(2020, 9, 30, 23, 18, 24), gtd=GranularityEnum.HOUR)
> dt == datetime(2020, 9, 30, 23, 0, 0)
True
```

**Запрос: "для текущего момента времени дай дату с отступом назад в 2 часа с предваряющей и последующей датами"**

Предположим, что сейчас на часах `2020-09-30T23:18:24`. 
Находим ближайшую валидную дату для нашей гранулярности `2020-09-30T23:00:00`. 
Далее отступаем назад на 2 часа. Получаем дату `2020-09-30T21:00:00`. Затем берем по таблице до нее и после нее. 
Получаем даты `2020-09-30T20:00:00, 2020-09-30T21:00:00, 2020-09-30T22:00:00`

```python
# Конструируем
> dt_range = DtRange(before=1, after=1, shift=-2, gtd=GranularityEnum.HOUR)
# Вызываем
> dts = dt_range(datetime(2020, 9, 30, 23, 18, 24))
> dts == [datetime(2020, 9, 30, 20, 0, 0), datetime(2020, 9, 30, 21, 0, 0), datetime(2020, 9, 30, 22, 0, 0)]
True
```

**Запрос: "для данного интервала дай все возможные даты"**

Предположим, что начало интервала `2020-09-30T23:18:24`, конец интервала `2020-10-01T02:00:00`.
Находим даты нужной нам гранулярности, которые попадают в интервал: `2020-10-01T00:00:00, 2020-10-01T01:00:00, 2020-10-01T02:00:00`. 
Обратите внимание, что дата `2020-09-30T23:00:00` не попадает в интервал.

```python
> dts = get_interval(datetime(2020, 9, 30, 23, 18, 24), datetime(2020, 10, 1, 2, 0, 0), gtd=GranularityEnum.HOUR)
> dts == [datetime(2020, 10, 1, 0, 0, 0), datetime(2020, 10, 1, 1, 0, 0), datetime(2020, 10, 1, 2, 0, 0)]
True
```

### FAQ

**Почему `DtRange` класс, а не функция?**

Мы хотим сформировать класс, который сможем вызывать для разных моментов времени

**Почему нужен `GranularityEnum`, можно ведь работать для любого timedelta?**

Мы не хотим, чтоб пользователи могли задавать свои гранулярности, а пользовались только существующими в нашем хранилище
