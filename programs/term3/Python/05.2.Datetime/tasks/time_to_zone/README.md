## TIME TO ZONE

`datetime` `timedelta` `aware` `naive` `zoneinfo`

### Условие

Нужно написать:

* Функцию `now`, которая возвращает `datetime` с текущим моментом времени
* Функцию `strftime`, которая превращает `datetime` в строку исходя из переданного формата
* Функцию `strptime`, которая превращает строку в `datetime` исходя из переданного формата
* Функцию `diff`, которая возвращает разницу между переданными `datetime`, приведенную к int. Предполагается, что `second_dt >= first_dt`
* Функцию `timestamp`, которая возвращает timestamp для переданного `datetime`, приведенный к int
* Функцию `from_timestamp`, которая превращает переданный timestamp в `datetime`

В чем отличие от обычных методов `datetime`:

* Любой `naive datetime` идущий на вход функциям, нужно интерпретировать как `datetime` в Московской таймзоне.
* Любой `aware datetime` идущий на вход функциям нужно обрабатывать в соответствии с его таймзоной.
* Любой возвращаемый `datetime` - это `aware datetime` в Московской таймзоне

Используйте [zoneinfo.ZoneInfo](https://docs.python.org/3/library/zoneinfo.html) для получения `tzinfo`.

### Про задачу

В Яндексе есть договоренность, что строковые datetime хранятся в Московской таймзоне. 
Часто таймзону явно не указывают, считая ее само собой разумеющейся. 
Также многие datetime хранятся в виде timestamp. 

Если на машинке, на которой неправильно выставлено локальное время, начать парсить без явного указания таймзоны, 
то могут наблюдаться интересные спецэффекты.
Например, любое сравнение с явно заданным `datetime` будет давать разный результат.
В лучшем случае - начинают мигать тесты, в худшем - в проде незаметным образом получаются неправильные результаты.

В этой задаче вы узнаете, как можно следить за `datetime`-ами, и добиваться их однозначной интерпретации вне зависимости
от локального времени.
