## Simple OS with multitasking

`OS design` `syscall` `cooperative multitasking` `generator` `coroutine`

### Цель

Вам нужно написать простенький шедулер для операционной системы, который бы работал с задачами в режиме
кооперативной многозадачности.

Ограничения и упрощения:
- код на питоне (никакой низкоуровневой магии на си/ассемблере)
- без тредов
- без сабпроцессинга
- generator-based корутины

Зачем? Чтобы потрогать корутины, а также получить базовое представление о том, как устроены операционные системы.
А также некоторый шаг в сторону понимания, как работает асинхронность в питоне (об этом подробнее далее в курсе).

### Устройство ОС "на пальцах"

#### Многозадачность

На уровне одного ядра процессора любая программа - это всего лишь набор инструкций, при выполнении которых
*не существует возможности* делать более одного действия одновременно.

Ни процессор, ни программы ничего не знают о многозадачности (с точки зрения того, что такое задача, и когда между
ними следует переключаться). За этим следит операционная система (ОС).

Современные многозадачные ОС (например, Windows, MacOS или Linux) создают видимость одновременной работы нескольких
программ за счет постоянного переключения между ними.

Но как именно ОС переключается между программами? Как она дает понять процессору, что пришло время сменить
программу A на программу B, и как сама операционная система понимает, что пришло это время?

Существует 2 механизма, которые дают ОС возможность управлять программами:
- аппаратные прерывания (hardware interrupts), т.е. события, которые исходят от внешних по отношению к процессору
аппаратных устройств: сработал таймер, нажата клавиша на клавиатуре, пришли данные по сети или с жесткого диска и т.п.;
- программные прерывания (software interrupts), т.е. события в самом процессоре, вызванные либо нарушением каких-то
условий при исполнении кода: деление на ноль, переполнение стека, обращение к недопустимым адресам памяти
или недопустимый код операции, либо инициированные текущей программой намеренно с целью обратиться к ОС.

Прерывания - это единственный способ взаимодействия с операционной системой для программ, поэтому любой
так называемый системный вызов (syscall) - это инструкция для процессора, которая генерирует прерывание,
после чего процессор автоматически приостанавливает выполнение программы и запускает код ОС в режиме повышенных
привелегий (прерывание нужно в т.ч. для смены режима работы процессора), чтобы обработать событие.

После завершения обработки события, выполнение программы продолжается с того же места, где оно было прервано, и она
может получить ответ на свой запрос от ОС (обычно он лежит на стеке или доступен в регистрах процессора).

Помимо добровольных прерываний, когда программа хочет повзаимодействовать с операционной системой, периодически
происходят прерывания выполнения программ по таймеру, запускается специальный код операционной системы (планировщик),
и может заменить текущую программу на другую. Этот механизм называется преемптивной (англ. preemtive) или вытесняющей
многозадачностью. Задачей планировщика является отслеживание времени выполнения программ и переключение между ними,
согласно их приоритету. Современные планировщики внутри ОС довольно сложны, но в простейшем случае это может быть
обычная очередь без приоритета (например, в данной задаче).

В нашей задаче мы не будем использовать таймер для переключения задач. Воспрользуемся другим механизмом - механизмом
кооперативной многозадачности. Кооперативная многозадачность в отличие от вытесняющей строится на том, что только
конкретная задача (программа) знает, когда её эффективнее всего прерывать, например, если прямо сейчас она ожидает
получения данных по сети, и ничего полезного до этого момента сделать не в состоянии. В таком случае задача может
самостоятельно уступить выполнение в пользу другой задачи. Более того, это единственный способ переключения между
задачами, поэтому если какая-то задача злоупотребит доверием и будет крутиться в вечном цикле, то никакая другая задача
не сможет быть выполнена, и смысла в такой "многозадачности" будет не много.

Данный способ, очевидно, не подходит для ОС, в которой должны уживаться множество независимых программ, в том числе
потенциально зловредных. Но в рамках одной программы этот подход к многозадачности может оказаться гораздо эффективнее,
т.к. переключения между задачами происходят только в тот момент, когда в них есть смысл (а любое переключение между
задачами довольно дорого, т.к. требует сохранить/восстановить контекст исполнения и пару раз поменять режим процессора).

#### Корутины для организации кооперативной многозадачности

Окей, кооперативная многозадачность - это круто, а причем тут питон?

Если вы внимательно слушали лекцию про генераторы, то возможно, вы обратили внимание, что `yield` для генераторов
по сути является прерыванием (выполнения генератора). Т.е. если интерпретатор встречает в коде `yield`, то он
немедленно приостанаваливает выполнение данного генератора, возвращает наружу некоторое значение, а после по
запросу управляющего кода (запустившего генератор) может продолжить выполнение генератора.

То есть, если предположить, что код, который запускает генераторы - это некоторый код операционной системы, а
код внутри самих генераторов - это задачи, то получается, что можно постороить некоторую упрощенную "операционную
систему".

В рамках данной задачи вам нужно будет написать лишь простенький планировщик задач и некоторую обертку над
генераторами, которая станет интерфейсом к задачам для вашего планировщика.

Кроме того, если вспомнить, что генераторы в питоне позволяют не только возвращать значения, но и передавать объекты
внутрь генератора, то можно воспользоваться этим, и договориться, что в рамках нашей задачи, генераторы должны
возвращать опреденные объекты (системные вызовы), которые позволят коду планировщика понять, чего от него хочет
данная задача (генератор).

Такие генераторы мы будем называть корутинами. Результат выполнения системного вызова наш планировщик будет
отправлять обратно в корутину, таким образом мы получим для корутин интерфейс взаимодействия, аналогичный настоящей ОС.

### Интерфейс для взаимодействия планировщика и задач

Итак, мы вводим 3 основных объекта, которые необходимо реализовать:
- `SystemCall`
- `Task`
- `Scheduler`

#### SystemCall

Системный вызов будет представлять из себя объект с единственным методом `handle`, который будет вызываться
планировщиком для совершения запрошенного действия.

```python
@abstractmethod
def handle(self, scheduler: 'Scheduler', task: 'Task') -> bool:
    """
    :param scheduler: link to scheduler to manipulate with active tasks
    :param task: task which requested the system call
    :return: an indication that the task must be scheduled again
    """
```

#### Task

Объект-обертка над корутиной (кодом задачи), который предоставляет планировщику интерфейс для пошагового запуска
(до ближайшего `yield` в коде корутины), а также хранит результат последнего системного вызова для передачи его
внутрь корутины (через `.send`).

```python
def step(self) -> SystemCall | None:
    """
    Performs one step of coroutine, i.e. sends result of last system call
    to coroutine (generator), gets yielded value and returns it.
    """
```

#### Scheduler

Основной класс, описывающий планировщик, содержит публичное апи, которое используется в тестах: `new` / `run` / `empty`,
и приватное апи, которое "доступно" только из методов самого планировщика и из системных вызовов: `*_task`.

Публичное апи состоит из трех методов, один из которых уже реализован для вас и используется в тестах, а два оставшихся
вам нужно реализовать самостоятельно.

`new` создает и возвращает id созданной задачи:

```python
def new(self, target: Coroutine) -> int:
    """
    Create and schedule new task
    :param target: coroutine to wrap in task
    :return: id of newly created task
    """
```

`run` запускает исполнение задач на N тиков (где тик - это 1 запуск метода `step` у задачи):

```python
def run(self, ticks: int | None = None) -> None:
    """
    Executes tasks consequentely, gets yielded system calls,
    handles them and reschedules task if needed
    :param ticks: number of iterations (task steps), infinite if not passed
    """
```

### Рекомендации по решению

Для начала реализуйте класс `Task`, который должен хранить переданной корутину и порядковый номер. Класс должен
предоставлять метод `step`, который возобновляет выполнение корутины, передав в нее результат последнего системного
вызова (результат вызова хранится в задаче и обновляется планировщиком извне).

Затем начните реализовывать класс `Scheduler`, для начала вам хватит методов `new` / `schedule_task` / `run`. Обратите
внимание на конструктор класса, его реализации вам должно хватить для решения задания (но можете его поменять
при желании).

Метод `new` по сути является оберткой над конструктором задачи, который еще и сохраняет задачу в планировщике, а
также планирует её для выполнения (`schedule_task`).

Задача метода `schedule_task` всего лишь положить задачу в очередь.

Метод `run` в первом приближении должен уметь извлекать задачу из очереди, запустить корутину до следующего `yield`,
и положить задачу обратно в конец очереди.

Этого вам должно хватить, чтобы пройти следующий тест.

Затем вам нужно будет поменять реализацию метода `run` так, чтобы он умел работать с задачами, которые завершаются,
а не выполняются бесконечно.

Здесь обратите внимание на тест `test_schedule_non_cooperative_tasks`, который наглядно демонстрирует, что будет,
если в коде, рассчитанном на кооперативную многозадачность, забить на переключение в коде самих задачах.

Так итеративно продолжайте модифицировать ваш код, пока не получите работающее решение.

Когда дойдете до системных вызовов, вам нужно будет научиться определять, что задача вернула вам объект `SystemCall`,
выполнить его обработчик и сохранить результат в задаче для того, чтобы позже передать его в корутину.

В общем-то и все, еще стоит обратить внимание на комментарии в тестах и коде, они подсказывают про пару граблей, на
которые вы можете наступить. Удачи!

### Про задачу

Эта задача призвана продемонстрировать, как устроен планировщик задач в ОС, а также поможет вам в дальнейшем понимать,
как работает кооперативная многозадачность, и почему важно в асинхронном коде явно указывать точки переключения
между задачами (`yield`, а в дальнейшем `yield from` и `await`).
