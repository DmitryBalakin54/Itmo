## Oh, my git

`git` `gitlab` `merge request`

## Задание

Важно: перед началом выполнения задания нужно создать отдельную ветку в основном репозитории, из которой потом будет делаться merge request в `main` (подробности в пункте "Отправка задания").

Это задание нужно, чтобы 'прочувствовать' гит. Вам дан архив `repo.zip`, который содержит заготовку игрушечного репозитория. Вам нужно распаковать архив и далее выполнить с репозиторием некоторые действия:
- вмерджить ветку `fast_forward_sender` в ветку `fast_forward_recepient` (`recepient`, а не `recipient`). Мердж должен пройти без создания доп коммита. Во всех задания ветки, которые вмердживаются, должны оставаться без изменений.
- вмерджить ветку `automerge_sender` в ветку `automerge_recepient`. Тут уже не обойтись без мердж коммита.
- вмерджить ветку `conflict_sender` в ветку `conflict_recepient` так, чтобы название функции осталось как в `conflict_sender`, а возвращаемое значение - как в `conflict_recepient`.
- в истории коммитов ветки `master` найти коммит, в котором лежит правильный "код" (см файлик `this_is_a_secret_file.md`). Код нужно вернуть из функции `get_secret_code` в `oh_my_git.py`
- откатить ветку `move_me_back` до того коммита `master`'a, где лежит правильный код.
- всю папку с репозиторием в том же виде, что было в исходном архиве, нужно запаковать обратно в zip архив под названием `repo_solved.zip`. После этого можно гонять локальные тесты через `pytest`, чтобы проверить, что все работает как надо.

Когда всё будет выполнено и запушено в ваше отдельную ветку нужно **в основном репозитории** создать мердж реквест из ветки, в которой делалось это задание, в ваш `main`.

Note: Для выполнения задания вам нужна библиотечка `GitPython`. В тестирующей система она **есть**. Писать setup **не** нужно


### Отправка задания

1. Создайте git-ветку `oh_my_git` для решения задачи. Рекомендации:
   * Если делаете это впервые, посмотрите обязательно видео `8.2.GitBranches` и почитайте секцию `Как оформить merge request`
   * Создайте ветку ДО ТОГО, как начали делать задание
   * Не забывайте переключаться обратно на `main`, когда будете коммитить другие задачи

2. Решите саму задачку. Закоммитьте изменения в ветку `oh_my_git`

3. Отправьте Merge request к себе в репозиторий, поставьте ему в gitlab'е label `oh_my_git`
и проверьте его корректность по чек-листу

4. Ждите проверки `MR`, баллы выставляются вручную после дедлайна задачи.  
  **Важно:** НЕ вмердживайте чертов MR сами. Ждите проверки!!!


### Чеклист содержимого мерджреквеста

* ✅ Merge request в свой репозиторий
* ✅ Вы создали и поставили label `oh_my_git` (иначе мы его не заметим даже)
* ✅ Находятся исключительно изменения в папке `oh_my_git` между версией из репозитория с задачами и вашей итоговой реализацией (Проверяйте это по вкладке `Changes`)
* ✅ Нет других задач, кроме oh_my_git
* ✅ Нет лишних случайно добавленных файлов
* ✅ Не добавили разархивированных ресурсов
* ✅ Прошли тесты в CI. Проверьте, что `Pipeline` в реквесте `passed`


<details><summary><b>P.S. Об особенностях выполнения задания на  WSL</b></summary>
При выполнении задания на WSL могут возникать некоторые артефакты. Например, WSL может автоматически менять права на r/w/x файлов. 
Поскольку git трактует `chmod` как изменение в файле, сразу же после распаковки `repo.zip` у вас появятся незакоммиченные изменения. Они, скорее всего, не дадут сделать задание без лишнего коммита, что в итоге приведёт к неправильной истории коммитов и провалу тестов.  
Бороться с этим можно разными способами; обычно помогает команда `git config core.fileMode false`. 
Если после распаковки `repo.zip` все файлы воспринимаются git'ом как unchanged, то значит, можно приступать к выполнению задания :).
</details>