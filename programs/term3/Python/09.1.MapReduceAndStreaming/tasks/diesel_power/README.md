## Diesel ~~Generator~~ Power

`mapreduce` `generators` `mapper` `reducer` `joiner` `heapq`

### Условие

В этом задании вы начнете работать над библиотекой для удобного запуска вычислений над таблицами.

В рамках этого задания (и последующей большой домашки) таблица - это последовательность словарей,
где каждый словарь — это строка таблицы, а ключ словаря — колонка таблицы
(индекс в последовательности + ключ в словаре задают ячейку).

### Операции

Для начала ограничимся лишь реализацией набора из 3-x базовых операций и некоторых отобранных
нами функций, которые помогут вам в последующем задании.

Казалось бы, операции над таблицами можно объявлять просто, как функции, принимающие таблицу и
возвращающие новую. Но мы поступим иначе: наши операции будут работать со строками таблицы, а не
с таблицей целиком. Так их будет проще применять - можно будет избегать лишних копирований
и много чего еще.

```python
class Operation(ABC):
    @abstractmethod
    def __call__(self, rows: TRowsIterable, *args: tp.Any, **kwargs: tp.Any) -> TRowsGenerator:
        pass
```

**Замечание**: конструкция с `abstractmethod`'ом позволяет создавать т.н. абстрактные классы - классы,
объекты которых нельзя создать. Это сделано для того, чтобы указать – данный класс не является
"самостоятельным", требуется создать класс-наследник с конкретной реализацией метода (или методов).
Объекты такого класса уже могут быть созданы. Обычно абстрактные классы используются для описания т.н.
интерфейса - некоторого шаблона, которому должны соответствовать потомки.

1. **`Map`** — операция, которая вызывает переданный генератор (называемый `Mapper`'ом) от каждой
из строк таблицы. Значения, выданные генератором, образуют таблицу-результат.
(Подходит для элементарных операций над строками - фильтраций, преобразований типов, элементарных
операций над полями таблицы etc).

```python
class Map(Operation):
    def __init__(self, mapper: Mapper) -> None:
        self.mapper = mapper

    def __call__(self, rows: TRowsIterable, *args: tp.Any, **kwargs: tp.Any) -> TRowsGenerator:
        pass
```

Мап в нашем задании не тождественен функции `map` из python, которая реализует соответствие 1-к-1
(наша по каждой строке может вернуть любое число строк).

Простейший маппер может быть таким:

```python
class DummyMapper(Mapper):
    def __call__(self, row: TRow) -> TRowsGenerator:
        yield row
```

Он просто пропускает через себя строки (довольно бесполезно, не правда ли?).

В рамках этого задания вам нужно будет реализовать 6 мапперов, интерфейсы и описание которых
вы можете найти в файле `operations.py`

2. **`Reduce`** принимает на вход таблицу, группирует её строки по ключу (где ключ - значение какого-то
подмножества колонок таблицы) и вызывает `Reducer` для строк с одинаковым ключом.

```python
class Reduce(Operation):
    def __init__(self, reducer: Reducer, keys: tp.Sequence[str]) -> None:
        self.reducer = reducer
        self.keys = keys

    def __call__(self, rows: TRowsIterable, *args: tp.Any, **kwargs: tp.Any) -> TRowsGenerator:
        pass
```

Для эффективной работы этой операции (за O(n)) таблица, подаваемая на вход, должна быть отсортирована
по колонкам, на которых операция запускается. Если посмотреть на запуски тестов редьюса, там это условие
явно выполняется. В рамках данного задания не требуется проверять входные данные на корректность. 

Интерфейс редьюсера:

```python
class Reducer(ABC):
    @abstractmethod
    def __call__(self, group_key: tp.Tuple[str, ...], rows: TRowsIterable) -> TRowsGenerator:
        pass
```

**Обратите внимание**: передаются не только строки таблицы, но и названия колонок, являющихся ключом.

Это важно для редьюсеров-сверток, которые осуществляют операцию сворачивания (`fold`) нескольких
строк в одну, применяя какую-нибудь ассоциативную операцию (например, суммируют значение в колонке).

Для колонок, не являющихся ключом группы, и на которые не распространяется операция свертки, есть
неоднозначность, поэтому данные колонки удаляются из вывода (см. `test_sum`, колонка `player_id`).

Пример редьюсера:

```python
class FirstReducer(Reducer):
    def __call__(self, group_key: tp.Tuple[str, ...], rows: TRowsIterable) -> TRowsGenerator:
        for row in rows:
            yield row
            break
```
Возвращает первую строчку из своей группы (такой `head` для бедных).

В рамках этого задания вам нужно реализовать 4 редьюсера (из них 2 сверточных).

3. **`Join`** — самая непростая операция, объединяющая информацию из двух таблиц в одну по ключу.
Строки новой таблицы будут созданы из строк двух таблиц, участвовавших в джойне. Интерфейс самой операции
похож на интерфейс `Reduce`:

```python
class Join(Operation):
    def __init__(self, joiner: Joiner, keys: tp.Sequence[str]) -> None:
        self.keys = keys
        self.joiner = joiner

    def __call__(self, rows: TRowsIterable, *args: tp.Any, **kwargs: tp.Any) -> TRowsGenerator:
        pass
```

Нужно сделать так, чтоб `Join` разбивал потоки на блоки по заданному ключу, и передавал их 
в некоторый объект `Joiner`, который уточняет требуемую стратегию слияния:

```python
class Joiner(ABC):
    def __init__(self, suffix_a: str = '_1', suffix_b: str = '_2') -> None:
        self._a_suffix = suffix_a
        self._b_suffix = suffix_b

    @abstractmethod
    def __call__(self, keys: tp.Sequence[str], rows_a: TRowsIterable, rows_b: TRowsIterable) -> TRowsGenerator:
        pass

```

Дело в том, что для join надо существуют несколько стратегий — `inner`, `outer`, `left` и `right`,
которые отличаются поведением при объединении колонок (например, что делать, если такого значения по 
данному ключу в одной из колонок нет).

Рекомендуется ознакомиться со статьёй [Join (SQL) на википедии](https://ru.wikipedia.org/wiki/Join_(SQL))
(понятно что не нужно реализовывать синтаксис SQL, только концептуальную идею).

Для каждой стратегии мы заготовили заглушку, которую вам будет необходимо заполнить:

```python
class InnerJoiner(Joiner):
    def __call__(self, keys: tp.Sequence[str], rows_a: TRowsIterable, rows_b: TRowsIterable) -> TRowsGenerator:
        pass
```

**Важное уточнение**: предусмотрите случай, когда у объединяемых таблиц есть колонки, называющиеся одинаково,
но при этом не входящие в ключ. Предлагается такие колонки переименовать, дописав соответствующий суффикс
(см. в `Joiner` `suffix_a` и `suffix_b`). Этот случай проверяется в последнем тесте, рекомендуется с ним
также ознакомиться.

**Важное уточнение 2**: сделайте так, чтоб в джойнерах не было копипасты. Join должен быть ответственен за нахождение блоков с общим ключем - эта часть общая для любого вида джойна. А джойнер принимает два таких блока и объединяет их.

### Замечания

* В задании нет приватных тестов, только публичные (гуляй, рванина!)

* Для операций `Map` / `Reduce` удобно начать с их реализации, проверив с помощью dummy-тестов,
а уже потом двигаться в сторону реализации конкретных мапперов/редьюсеров.

**И ещё кое-что**: предполагается, что данное задание вы сможете без изменений (или почти без изменений)
включить во вторую большую домашку (которая, о ужас! с код-ревью), поэтому пишите сразу хороший код :)

### Подсказки

* В `TopN` вам нужно подумать, как в памяти хранить всего N объектов. У вас была задача, где вы так делали
* В `Split` вас нужно воспроизвести логику питоновского `split`. 
Когда он без параметра, то разбивать по пробельным символам. 
Вам может пригодиться [`https://docs.python.org/3.9/library/re.html#re.split`](https://docs.python.org/3.9/library/re.html#re.split).
Регулярное выражение для пробельных символов – `\s+`.
* В `Join` для поиска блоков с одинаковым ключом для последующего запуска Joiner, нужно вспомнить, что два потока отсортированы. У вас была задача, где вы делали подобное
* В `Reduce` и `Join` вам пригодится [`groupby`](https://docs.python.org/3/library/itertools.html#itertools.groupby)
