## AI Generator

Вы разрабатываете серверную часть генератора картинок по текстовому описанию пользователей с использованием искусственного интеллекта.
Вам на вход подается канал с запросами на генерацию, необходимая параллельность генерации и лямбда функция, которая генерирует изображение по запросу.
Ваша задача - обрабатывать запросы по мере их поступления и генерировать изображения параллельно. При этом необходимо поддержать кеширование и не генерировать изображение для того же запроса дважды.

Конструктор класса `ImageProcessor` принимает 
* `parallelism: Int` - число потоков, которые нужно использовать для параллельной генерации изображений;
* `requests: ReceiveChannel<String>` - канал текстовых описаний запросов генерируемых изображений;
* `publications: SendChannel<Pair<String, ByteArray>>` - канал, в который необходимо публиковать готовые изображения;
* `generator: ImageGenerator` - функция, в которой скрыт процесс генерации изображения по описанию.

Метод `run(scope: CoroutineScope)` должен запускать чтение канала `requests` и генерацию изображений в переданном `CoroutineScope` и завершаться после запуска.
Запущенная генерация изображений должна происходить до тех пор, пока канал `requests` не будет закрыт.
После закрытия канала нужно освободить все используемые ресурсы.

Сгенерированное изображение нужно один раз послать в канал `publications` в виде пары из исходного текстового запроса и полученного из функции `generator` байтового представления изображения (в виде `ByteArray`).

Одновременно может запускаться __не более__ `parallelism` функций типа `ImageGenerator`.
Если в канале появляется запрос, изображение для которого уже было сгенерировано или генерируется сейчас, генерировать изображение повторно __не требуется__ (и не допускается).

Для синхронизации между корутинами в реализации можно использовать только `kotlinx.coroutines.channels` и связанные с каналами функции.
